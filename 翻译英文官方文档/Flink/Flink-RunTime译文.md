# 分布式运行时间

## 任务和操作链

为了分布式操作，Flink 将多个子操作连接进一个任务。任何每一个任务是一个执行器，运行在一个线程上。连接子操作进入任务是一种有用的优化：

- 减少线程与线程间的切换，缓存
- 增加并行度，并减少延迟 
  这个连接操作可以通过API进行配置。

看这个 chaining 文档了解详情

下图中的示例数据流使用5个子任务执行，因此使用5个并行线程执行。

## 作业管理，任务管理，客户端

一个集群中有两个进程： job manager 和 task manager 

* job manager:负责协调分布式执行器，检查点，重启失败的任务，任务只执行表构建。在集群中必须存在一个 job manager ，在高可用环境中一个领导者多个学习者。 
* task manager: 为了数据流执行任务，或者更多指定的子执行器。缓存和交换数据流。集群中最少有一个 task manager. job 和 task 可以以多种方式运行。例如运行于 资源管理器 Yarn  或 Mesos上。也可以单独运行。 
* 客户端：准备数据流，构建操作图，并提交到集群。在这之后客户端可以选择断开连接，或保持连接。保持连接时将受到进度报告。这个客户端可以作为 Java/Scala 代码的一部分提交，或者通过命令 提交 bin/flink run ...

## 任务 slot 和资源管理

任何一个 taskmanager 都是一个 JVM 进程，执行器和子操作运行于不同的线程上。一个task manager 使用 任务 slot 控制 多个任务。 
taskmanager 为了资源管理准备了多个任务slot。举个栗子，taskmanager 用三分之的内存 准备了3个任务槽。为了内存管理每一个 slot 的计算内存不能互相影响，而是有一定预留的托管内存。这个slot不能做到 CPU 隔离，仅仅只能管理内存。 
task slot是可以调节的，用户能定义如何隔离的子任务。每一个 task manager 有一个slot，这意味着每一个任务组运行于一个隔离的 JVM 中。多个 slot 意味着有多个子任务共享同一个 JVM。task 运行于相同的 JVM 中共享 TCP连接，多路复用，和心跳消息。他们还可以共享数据集和数据结构，因此 减少了每一个作业的开销。 
默认情况下， Flink 所有的 子操作 共享 slot，即使这些子任务属于不同的 task ，只要他们来自于同一个 job. 这个结果是有一个 slot 为整个 job 提供了一个管道。所有的 slot 共享这个 管道有两个收益：

- 一个 Flink 集群中运行着许多 task 用于一个 高并发 job。在整个程序中不需要统计有多少个 task（用于不同的并行度）
- 它可以非常简便的获取资源的高度利用。如果没有 slot 共享，非密集型 source()/map() 操作与资源密集型 window 子任务阻塞的一样多。用 slot 共享，在我们的例子中并行度从 2提高到6，同时保障了繁重的子任务得到了均衡调度。 
  API 包含一个资源组机制，它可以设置不共享 slot。 
  根据经验，一个 taskManager 中包含的 slot 应该和 CPU 核数相同。如果是超线程CPU 应该是1:2

## 状态备份

在状态备份（state backend）中选择 key/value 索引存储状态数据是可靠的，这个状态数据是明确的数据结构。一个状态数据以hash映射的方式存储在内存中，其他的状态数据使用 RocksDB 存储，RocksDB 是一种 key/value 存储。除了保存状态的数据结构外，状态备份还实现了逻辑快照，获取键/值状态的时间点快照并将该快照存储为检查点的一部分。

## 存储点

程序写入数据流能够从 存储点 重新开始写入。 在不丢失任何状态下，存储点准许更新你的程序和你的 Flink 集群。 
存储点是手动触发的检查点，选择哪一个镜像用于程序和写入点的一个备份。为此它们常常依赖常规检查点的机制。在工作节点和生产检查点为执行程序定期创建镜像。无论如何仅从最新的完整检查点恢复，旧的检查点被确认可以丢弃。 
存储点与这些定期检查点类似，不同之处在于它们是由用户触发的，并且在完成新检查点时不会自动过期。存储点可以从命令行创建，也在取消 job 时通过 REST API 创建。